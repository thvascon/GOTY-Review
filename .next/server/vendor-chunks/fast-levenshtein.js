/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-levenshtein";
exports.ids = ["vendor-chunks/fast-levenshtein"];
exports.modules = {

/***/ "(rsc)/./node_modules/fast-levenshtein/levenshtein.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-levenshtein/levenshtein.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n  'use strict';\n  \n  var collator;\n  try {\n    collator = (typeof Intl !== \"undefined\" && typeof Intl.Collator !== \"undefined\") ? Intl.Collator(\"generic\", { sensitivity: \"base\" }) : null;\n  } catch (err){\n    console.log(\"Collator could not be initialized and wouldn't be used\");\n  }\n  // arrays to re-use\n  var prevRow = [],\n    str2Char = [];\n  \n  /**\n   * Based on the algorithm at http://en.wikipedia.org/wiki/Levenshtein_distance.\n   */\n  var Levenshtein = {\n    /**\n     * Calculate levenshtein distance of the two strings.\n     *\n     * @param str1 String the first string.\n     * @param str2 String the second string.\n     * @param [options] Additional options.\n     * @param [options.useCollator] Use `Intl.Collator` for locale-sensitive string comparison.\n     * @return Integer the levenshtein distance (0 and above).\n     */\n    get: function(str1, str2, options) {\n      var useCollator = (options && collator && options.useCollator);\n      \n      var str1Len = str1.length,\n        str2Len = str2.length;\n      \n      // base cases\n      if (str1Len === 0) return str2Len;\n      if (str2Len === 0) return str1Len;\n\n      // two rows\n      var curCol, nextCol, i, j, tmp;\n\n      // initialise previous row\n      for (i=0; i<str2Len; ++i) {\n        prevRow[i] = i;\n        str2Char[i] = str2.charCodeAt(i);\n      }\n      prevRow[str2Len] = str2Len;\n\n      var strCmp;\n      if (useCollator) {\n        // calculate current row distance from previous row using collator\n        for (i = 0; i < str1Len; ++i) {\n          nextCol = i + 1;\n\n          for (j = 0; j < str2Len; ++j) {\n            curCol = nextCol;\n\n            // substution\n            strCmp = 0 === collator.compare(str1.charAt(i), String.fromCharCode(str2Char[j]));\n\n            nextCol = prevRow[j] + (strCmp ? 0 : 1);\n\n            // insertion\n            tmp = curCol + 1;\n            if (nextCol > tmp) {\n              nextCol = tmp;\n            }\n            // deletion\n            tmp = prevRow[j + 1] + 1;\n            if (nextCol > tmp) {\n              nextCol = tmp;\n            }\n\n            // copy current col value into previous (in preparation for next iteration)\n            prevRow[j] = curCol;\n          }\n\n          // copy last col value into previous (in preparation for next iteration)\n          prevRow[j] = nextCol;\n        }\n      }\n      else {\n        // calculate current row distance from previous row without collator\n        for (i = 0; i < str1Len; ++i) {\n          nextCol = i + 1;\n\n          for (j = 0; j < str2Len; ++j) {\n            curCol = nextCol;\n\n            // substution\n            strCmp = str1.charCodeAt(i) === str2Char[j];\n\n            nextCol = prevRow[j] + (strCmp ? 0 : 1);\n\n            // insertion\n            tmp = curCol + 1;\n            if (nextCol > tmp) {\n              nextCol = tmp;\n            }\n            // deletion\n            tmp = prevRow[j + 1] + 1;\n            if (nextCol > tmp) {\n              nextCol = tmp;\n            }\n\n            // copy current col value into previous (in preparation for next iteration)\n            prevRow[j] = curCol;\n          }\n\n          // copy last col value into previous (in preparation for next iteration)\n          prevRow[j] = nextCol;\n        }\n      }\n      return nextCol;\n    }\n\n  };\n\n  // amd\n  if ( true && __webpack_require__.amdD !== null && __webpack_require__.amdO) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return Levenshtein;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  // commonjs\n  else if ( true && module !== null && typeof exports !== \"undefined\" && module.exports === exports) {\n    module.exports = Levenshtein;\n  }\n  // web worker\n  else if (typeof self !== \"undefined\" && typeof self.postMessage === 'function' && typeof self.importScripts === 'function') {\n    self.Levenshtein = Levenshtein;\n  }\n  // browser main thread\n  else if (typeof window !== \"undefined\" && window !== null) {\n    window.Levenshtein = Levenshtein;\n  }\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmFzdC1sZXZlbnNodGVpbi9sZXZlbnNodGVpbi5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSCxxQkFBcUI7QUFDdkksSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQzs7QUFFQSxzQkFBc0IsYUFBYTtBQUNuQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQzs7QUFFQSxzQkFBc0IsYUFBYTtBQUNuQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNLEtBQTZCLElBQUksd0JBQU0sYUFBYSx3QkFBVTtBQUNwRSxJQUFJLG1DQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQUEsa0dBQUM7QUFDTjtBQUNBO0FBQ0EsV0FBVyxLQUE2QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi9ob21lL0VzdHVkby9TaXRlIEdhbWVzIFNjb3JlL2dhbWUtcmV2aWV3LXNxdWFkLW1haW4vbm9kZV9tb2R1bGVzL2Zhc3QtbGV2ZW5zaHRlaW4vbGV2ZW5zaHRlaW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgY29sbGF0b3I7XG4gIHRyeSB7XG4gICAgY29sbGF0b3IgPSAodHlwZW9mIEludGwgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIEludGwuQ29sbGF0b3IgIT09IFwidW5kZWZpbmVkXCIpID8gSW50bC5Db2xsYXRvcihcImdlbmVyaWNcIiwgeyBzZW5zaXRpdml0eTogXCJiYXNlXCIgfSkgOiBudWxsO1xuICB9IGNhdGNoIChlcnIpe1xuICAgIGNvbnNvbGUubG9nKFwiQ29sbGF0b3IgY291bGQgbm90IGJlIGluaXRpYWxpemVkIGFuZCB3b3VsZG4ndCBiZSB1c2VkXCIpO1xuICB9XG4gIC8vIGFycmF5cyB0byByZS11c2VcbiAgdmFyIHByZXZSb3cgPSBbXSxcbiAgICBzdHIyQ2hhciA9IFtdO1xuICBcbiAgLyoqXG4gICAqIEJhc2VkIG9uIHRoZSBhbGdvcml0aG0gYXQgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXZlbnNodGVpbl9kaXN0YW5jZS5cbiAgICovXG4gIHZhciBMZXZlbnNodGVpbiA9IHtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgbGV2ZW5zaHRlaW4gZGlzdGFuY2Ugb2YgdGhlIHR3byBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0cjEgU3RyaW5nIHRoZSBmaXJzdCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHN0cjIgU3RyaW5nIHRoZSBzZWNvbmQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBbb3B0aW9ucy51c2VDb2xsYXRvcl0gVXNlIGBJbnRsLkNvbGxhdG9yYCBmb3IgbG9jYWxlLXNlbnNpdGl2ZSBzdHJpbmcgY29tcGFyaXNvbi5cbiAgICAgKiBAcmV0dXJuIEludGVnZXIgdGhlIGxldmVuc2h0ZWluIGRpc3RhbmNlICgwIGFuZCBhYm92ZSkuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihzdHIxLCBzdHIyLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdXNlQ29sbGF0b3IgPSAob3B0aW9ucyAmJiBjb2xsYXRvciAmJiBvcHRpb25zLnVzZUNvbGxhdG9yKTtcbiAgICAgIFxuICAgICAgdmFyIHN0cjFMZW4gPSBzdHIxLmxlbmd0aCxcbiAgICAgICAgc3RyMkxlbiA9IHN0cjIubGVuZ3RoO1xuICAgICAgXG4gICAgICAvLyBiYXNlIGNhc2VzXG4gICAgICBpZiAoc3RyMUxlbiA9PT0gMCkgcmV0dXJuIHN0cjJMZW47XG4gICAgICBpZiAoc3RyMkxlbiA9PT0gMCkgcmV0dXJuIHN0cjFMZW47XG5cbiAgICAgIC8vIHR3byByb3dzXG4gICAgICB2YXIgY3VyQ29sLCBuZXh0Q29sLCBpLCBqLCB0bXA7XG5cbiAgICAgIC8vIGluaXRpYWxpc2UgcHJldmlvdXMgcm93XG4gICAgICBmb3IgKGk9MDsgaTxzdHIyTGVuOyArK2kpIHtcbiAgICAgICAgcHJldlJvd1tpXSA9IGk7XG4gICAgICAgIHN0cjJDaGFyW2ldID0gc3RyMi5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuICAgICAgcHJldlJvd1tzdHIyTGVuXSA9IHN0cjJMZW47XG5cbiAgICAgIHZhciBzdHJDbXA7XG4gICAgICBpZiAodXNlQ29sbGF0b3IpIHtcbiAgICAgICAgLy8gY2FsY3VsYXRlIGN1cnJlbnQgcm93IGRpc3RhbmNlIGZyb20gcHJldmlvdXMgcm93IHVzaW5nIGNvbGxhdG9yXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdHIxTGVuOyArK2kpIHtcbiAgICAgICAgICBuZXh0Q29sID0gaSArIDE7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc3RyMkxlbjsgKytqKSB7XG4gICAgICAgICAgICBjdXJDb2wgPSBuZXh0Q29sO1xuXG4gICAgICAgICAgICAvLyBzdWJzdHV0aW9uXG4gICAgICAgICAgICBzdHJDbXAgPSAwID09PSBjb2xsYXRvci5jb21wYXJlKHN0cjEuY2hhckF0KGkpLCBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0cjJDaGFyW2pdKSk7XG5cbiAgICAgICAgICAgIG5leHRDb2wgPSBwcmV2Um93W2pdICsgKHN0ckNtcCA/IDAgOiAxKTtcblxuICAgICAgICAgICAgLy8gaW5zZXJ0aW9uXG4gICAgICAgICAgICB0bXAgPSBjdXJDb2wgKyAxO1xuICAgICAgICAgICAgaWYgKG5leHRDb2wgPiB0bXApIHtcbiAgICAgICAgICAgICAgbmV4dENvbCA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlbGV0aW9uXG4gICAgICAgICAgICB0bXAgPSBwcmV2Um93W2ogKyAxXSArIDE7XG4gICAgICAgICAgICBpZiAobmV4dENvbCA+IHRtcCkge1xuICAgICAgICAgICAgICBuZXh0Q29sID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb3B5IGN1cnJlbnQgY29sIHZhbHVlIGludG8gcHJldmlvdXMgKGluIHByZXBhcmF0aW9uIGZvciBuZXh0IGl0ZXJhdGlvbilcbiAgICAgICAgICAgIHByZXZSb3dbal0gPSBjdXJDb2w7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY29weSBsYXN0IGNvbCB2YWx1ZSBpbnRvIHByZXZpb3VzIChpbiBwcmVwYXJhdGlvbiBmb3IgbmV4dCBpdGVyYXRpb24pXG4gICAgICAgICAgcHJldlJvd1tqXSA9IG5leHRDb2w7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBjYWxjdWxhdGUgY3VycmVudCByb3cgZGlzdGFuY2UgZnJvbSBwcmV2aW91cyByb3cgd2l0aG91dCBjb2xsYXRvclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyMUxlbjsgKytpKSB7XG4gICAgICAgICAgbmV4dENvbCA9IGkgKyAxO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IHN0cjJMZW47ICsraikge1xuICAgICAgICAgICAgY3VyQ29sID0gbmV4dENvbDtcblxuICAgICAgICAgICAgLy8gc3Vic3R1dGlvblxuICAgICAgICAgICAgc3RyQ21wID0gc3RyMS5jaGFyQ29kZUF0KGkpID09PSBzdHIyQ2hhcltqXTtcblxuICAgICAgICAgICAgbmV4dENvbCA9IHByZXZSb3dbal0gKyAoc3RyQ21wID8gMCA6IDEpO1xuXG4gICAgICAgICAgICAvLyBpbnNlcnRpb25cbiAgICAgICAgICAgIHRtcCA9IGN1ckNvbCArIDE7XG4gICAgICAgICAgICBpZiAobmV4dENvbCA+IHRtcCkge1xuICAgICAgICAgICAgICBuZXh0Q29sID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVsZXRpb25cbiAgICAgICAgICAgIHRtcCA9IHByZXZSb3dbaiArIDFdICsgMTtcbiAgICAgICAgICAgIGlmIChuZXh0Q29sID4gdG1wKSB7XG4gICAgICAgICAgICAgIG5leHRDb2wgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvcHkgY3VycmVudCBjb2wgdmFsdWUgaW50byBwcmV2aW91cyAoaW4gcHJlcGFyYXRpb24gZm9yIG5leHQgaXRlcmF0aW9uKVxuICAgICAgICAgICAgcHJldlJvd1tqXSA9IGN1ckNvbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjb3B5IGxhc3QgY29sIHZhbHVlIGludG8gcHJldmlvdXMgKGluIHByZXBhcmF0aW9uIGZvciBuZXh0IGl0ZXJhdGlvbilcbiAgICAgICAgICBwcmV2Um93W2pdID0gbmV4dENvbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHRDb2w7XG4gICAgfVxuXG4gIH07XG5cbiAgLy8gYW1kXG4gIGlmICh0eXBlb2YgZGVmaW5lICE9PSBcInVuZGVmaW5lZFwiICYmIGRlZmluZSAhPT0gbnVsbCAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIExldmVuc2h0ZWluO1xuICAgIH0pO1xuICB9XG4gIC8vIGNvbW1vbmpzXG4gIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlICE9PSBudWxsICYmIHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzID09PSBleHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMZXZlbnNodGVpbjtcbiAgfVxuICAvLyB3ZWIgd29ya2VyXG4gIGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBzZWxmLnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzZWxmLmltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzZWxmLkxldmVuc2h0ZWluID0gTGV2ZW5zaHRlaW47XG4gIH1cbiAgLy8gYnJvd3NlciBtYWluIHRocmVhZFxuICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCkge1xuICAgIHdpbmRvdy5MZXZlbnNodGVpbiA9IExldmVuc2h0ZWluO1xuICB9XG59KCkpO1xuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fast-levenshtein/levenshtein.js\n");

/***/ })

};
;